#!/usr/bin/env python3
import re
import sys
import json
import asyncio
import subprocess
from subprocess import check_output

usage = {}

MY_USERNAME = check_output("whoami", text=True).strip()
MY_UID = check_output(["id", "-u", MY_USERNAME], text=True).strip()


async def main():
    print("collecting info from slurm...", file=sys.stderr)
    squeue_me = json.loads(check_output("squeue --me --json", shell=True))

    for job in squeue_me["jobs"]:
        if job["job_state"] != ["RUNNING"]:
            continue
        jobid = job["job_id"]
        for allocated_node in job["job_resources"]["allocated_nodes"]:
            hostname = allocated_node["nodename"]
            if jobid not in usage:
                usage[jobid] = {}
            if hostname not in usage[jobid]:
                usage[jobid][hostname] = {}
            # cgroup = f"slurm_{hostname}/uid_{my_uid}/job_{jobid}"
            usage[jobid][hostname] = {
                "pct_cpu_usage": 0,
                "pct_cpu_limit": 100 * allocated_node["cpus_used"],
                "mem_bytes_usage": 0,
                "mem_bytes_limit": 1000000 * allocated_node["memory_allocated"],
            }

    await spawn_cgtop_ssh_sessions()


async def spawn_cgtop_ssh_sessions():
    hostnames = set()
    for job_usage in usage.values():
        for hostname in job_usage:
            hostnames.add(hostname)
    tasks = []
    for hostname in hostnames:
        tasks.append(run_cgtop_on_node(hostname))
    await asyncio.gather(*tasks)


async def run_cgtop_on_node(hostname) -> None:
    # with a 1 second period, this would stop after 4 years or so
    cmd = f"ssh '{hostname}' systemd-cgtop --raw -n 999999999 'slurm_{hostname}'"
    proc = await asyncio.create_subprocess_shell(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE
    )
    async for line in proc.stdout:
        if not line:
            break
        line = line.decode().strip()
        # print(f'line received: "{line}"')
        try:
            cgroup, _, cpu_usage, mem_usage, _, _ = line.strip().split()
        except ValueError:
            # print(
            #     f'systemd-cgtop output "{line}" could not be split into 6 words!', file=sys.stderr
            # )
            continue
        try:
            jobid = int(
                re.fullmatch(rf"slurm_{hostname}/uid_{MY_UID}/job_(\d+)", cgroup).groups(1)[0]
            )
        except AttributeError:
            # print(f'cgroup not relevant: "{cgroup}"', file=sys.stderr)
            continue
        if jobid not in usage:
            # print(f'jobid not relevant: "{jobid}"', file=sys.stderr)
            continue
        usage[jobid][hostname]["pct_cpu_usage"] = process_cgtop_cpu_usage(cpu_usage)
        usage[jobid][hostname]["mem_bytes_usage"] = process_cgtop_mem_usage(mem_usage)
        update_usage_display()
    await proc.wait()
    print(f"SSH session closed on host {hostname}!", file=sys.stderr)
    print(proc)
    sys.exit(1)

def process_cgtop_cpu_usage(x:str) -> float:
    if x == "-":
        return 0
    return float(x)

def process_cgtop_mem_usage(x:str) -> float:
    if x == "-":
        return 0
    return float(x)

def clear_terminal_scrollback():
    sys.stdout.write("\033c\033[3J")
    sys.stdout.flush()

def quotient_between_0_1(num, den):
    assert not (num > den)
    assert (num >= 0) and (den >= 0)
    if num == 0 and den == 0:
        return 0
    # throws ZeroDivisionError for 0 den
    return num / den


def closest_element_index(_list, target) -> int:
    """
    return the index of the list element which is closest to target
    """
    min_diff = None
    min_diff_index = -1
    for i, element in enumerate(_list):
        diff = element - target
        if i == 0 or abs(diff) < abs(min_diff):
            min_diff = diff
            min_diff_index = i
    return min_diff_index


def generate_progress_bar(frac: float, _len=20) -> str:
    assert frac >= 0 and frac <= 1
    _len -= 2  # subtract beginning and end characters
    num_chars2frac = [x / _len for x in range(_len + 1)]  # [ 0, 1/len, 2/len, ... len/len=1 ]
    num_chars = closest_element_index(
        num_chars2frac, frac
    )  # round `frac` to the nearest character length fraction
    progress_bar = "[" + ("#" * num_chars) + (" " * (_len - num_chars)) + "]"
    return progress_bar

def human_readable(x:int) -> str:
    output = x
    output_suffix = ""
    for suffix in ["K", "M", "G"]:
        if output > 1000:
            output /= 1000
            output_suffix = suffix
    if int(output) == output:
        return f'{int(output)}{output_suffix}'
    return f'{output:.3f}{output_suffix}'


def update_usage_display():
    # print(json.dumps(usage, indent=4))
    clear_terminal_scrollback()
    for jobid, hostname2job_usage in usage.items():
        print(f"job {jobid}:")
        for hostname, job_usage in hostname2job_usage.items():
            print(f'  {hostname}:')
            cpu_usage_frac = min([1, job_usage["pct_cpu_usage"]/job_usage["pct_cpu_limit"]])
            mem_usage_frac = min([1, job_usage["mem_bytes_usage"]/job_usage["mem_bytes_limit"]])
            cpu_progress_bar = generate_progress_bar(cpu_usage_frac, _len=40)
            mem_progress_bar = generate_progress_bar(mem_usage_frac, _len=40)
            cpu_frac_str = f'{(job_usage["pct_cpu_usage"]/100):.2f} / {int(job_usage["pct_cpu_limit"]/100)}'
            mem_frac_str = f'{human_readable(job_usage["mem_bytes_usage"])} / {human_readable(job_usage["mem_bytes_limit"])}'
            print(f'    CPU: {cpu_progress_bar} {cpu_frac_str} cores')
            print(f'    MEM: {mem_progress_bar} {mem_frac_str} bytes')
        print()


if __name__ == "__main__":
    asyncio.run(main())
